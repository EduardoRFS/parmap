<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parmap (parmap.Parmap)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">parmap</a> &#x00BB; Parmap</nav><h1>Module <code>Parmap</code></h1><p>Module <code>Parmap</code>: efficient parallel map, fold and mapfold on lists and arrays on multicores.</p><p>All the primitives allow to control the granularity of the parallelism via an optional parameter <code>chunksize</code>: if <code>chunksize</code> is omitted, the input sequence is split evenly among the available cores; if <code>chunksize</code> is specified, the input data is split in chunks of size <code>chunksize</code> and dispatched to the available cores using an on demand strategy that ensures automatic load balancing.</p><p>A specific primitive <a href="index.html#val-array_float_parmap"><code>array_float_parmap</code></a> is provided for fast operations on float arrays.</p><nav class="toc"><ul><li><a href="#configuring-available-cores">Configuring available cores</a><ul><li><a href="#setting-and-getting-the-default-value-for-ncores">Setting and getting the default value for ncores</a></li><li><a href="#getting-ncores-being-used-during-parallel-execution">Getting ncores being used during parallel execution</a></li><li><a href="#enabling/disabling-processes-core-pinning">Enabling/disabling processes core pinning</a></li><li><a href="#setting-and-getting-an-explicity-mapping-from-processes-to-cores">Setting and getting an explicity mapping from processes to cores</a></li></ul></li><li><a href="#parallel-map-and-folds">Parallel map and folds</a><ul><li><a href="#generic-operations">Generic operations</a><ul><li><a href="#parallel-mapfold">Parallel mapfold</a></li><li><a href="#parallel-fold">Parallel fold</a></li><li><a href="#parallel-map">Parallel map</a></li><li><a href="#parallel-iteration">Parallel iteration</a></li><li><a href="#parallel-mapfold,-indexed">Parallel mapfold, indexed</a></li><li><a href="#parallel-map,-indexed">Parallel map, indexed</a></li><li><a href="#parallel-iteration,-indexed">Parallel iteration, indexed</a></li><li><a href="#parallel-map-on-arrays">Parallel map on arrays</a></li><li><a href="#parallel-map-on-arrays,-indexed">Parallel map on arrays, indexed</a></li></ul></li><li><a href="#float-array-operations">Float array operations</a><ul><li><a href="#parallel-map-on-float-arrays">Parallel map on float arrays</a></li><li><a href="#parallel-map-on-float-arrays,-indexed">Parallel map on float arrays, indexed</a></li></ul></li></ul></li><li><a href="#debugging-and-helpers">Debugging and Helpers</a></li></ul></nav></header><section><header><h2 id="configuring-available-cores"><a href="#configuring-available-cores" class="anchor"></a>Configuring available cores</h2></header><section><header><h3 id="setting-and-getting-the-default-value-for-ncores"><a href="#setting-and-getting-the-default-value-for-ncores" class="anchor"></a>Setting and getting the default value for ncores</h3></header><dl><dt class="spec value" id="val-set_default_ncores"><a href="#val-set_default_ncores" class="anchor"></a><code><span class="keyword">val</span> set_default_ncores : int <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_default_ncores"><a href="#val-get_default_ncores" class="anchor"></a><code><span class="keyword">val</span> get_default_ncores : unit <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h3 id="getting-ncores-being-used-during-parallel-execution"><a href="#getting-ncores-being-used-during-parallel-execution" class="anchor"></a>Getting ncores being used during parallel execution</h3></header><dl><dt class="spec value" id="val-get_ncores"><a href="#val-get_ncores" class="anchor"></a><code><span class="keyword">val</span> get_ncores : unit <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h3 id="enabling/disabling-processes-core-pinning"><a href="#enabling/disabling-processes-core-pinning" class="anchor"></a>Enabling/disabling processes core pinning</h3></header><dl><dt class="spec value" id="val-disable_core_pinning"><a href="#val-disable_core_pinning" class="anchor"></a><code><span class="keyword">val</span> disable_core_pinning : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>disable_core_pinning ()</code> will prevent forked out processes from being pinned to a specific core. WARNING: this may have a negative impact on performance, but might be necessary on systems where several parmap computations are running concurrently.</p></dd></dl><dl><dt class="spec value" id="val-enable_core_pinning"><a href="#val-enable_core_pinning" class="anchor"></a><code><span class="keyword">val</span> enable_core_pinning : unit <span>&#45;&gt;</span> unit</code></dt><dd><p><code>enable_core_pinning ()</code> turns on core pinning (it is on by default).</p></dd></dl></section><section><header><h3 id="setting-and-getting-an-explicity-mapping-from-processes-to-cores"><a href="#setting-and-getting-an-explicity-mapping-from-processes-to-cores" class="anchor"></a>Setting and getting an explicity mapping from processes to cores</h3></header><dl><dt class="spec value" id="val-set_core_mapping"><a href="#val-set_core_mapping" class="anchor"></a><code><span class="keyword">val</span> set_core_mapping : <span>int array</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_core_mapping m</code> installs the array <code>m</code> as the mapping to be used to pin processes to cores. Process <code>i</code> will be pinned to core <code>m.(i mod Array.length m)</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_rank"><a href="#val-get_rank" class="anchor"></a><code><span class="keyword">val</span> get_rank : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Getting the current worker rank.</p><p>The master process has rank -1. Other processes have the rank at which they were forked out (a worker's rank is in <code>0..ncores-1</code>)</p></dd></dl></section></section><section><header><h2 id="parallel-map-and-folds"><a href="#parallel-map-and-folds" class="anchor"></a>Parallel map and folds</h2></header><dl><dt class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><code><span class="keyword">type</span> <span>'a sequence</span></code><code> = </code><table class="variant"><tr id="type-sequence.L" class="anchored"><td class="def constructor"><a href="#type-sequence.L" class="anchor"></a><code>| </code><code><span class="constructor">L</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> list</span></code></td></tr><tr id="type-sequence.A" class="anchored"><td class="def constructor"><a href="#type-sequence.A" class="anchor"></a><code>| </code><code><span class="constructor">A</span> <span class="keyword">of</span> <span><span class="type-var">'a</span> array</span></code></td></tr></table></dt></dl><section><header><h3 id="generic-operations"><a href="#generic-operations" class="anchor"></a>Generic operations</h3></header><aside><p>The <a href="index.html#val-parmapfold"><code>parmapfold</code></a>, <a href="index.html#val-parfold"><code>parfold</code></a> and <a href="index.html#val-parmap"><code>parmap</code></a> generic functions, for efficiency reasons, convert the input data into an array internally, so we provide the <code>'a sequence</code> type to allow passing an array directly as input. If you want to perform a parallel map operation on an array, use <a href="index.html#val-array_parmap"><code>array_parmap</code></a> or <a href="index.html#val-array_float_parmap"><code>array_float_parmap</code></a> instead.</p></aside><aside><p>The optional <code>init</code> (resp. <code>finalize</code>) function is called once by each child process just after creation (resp. just before exit). <code>init</code> and <code>finalize</code> both default to doing nothing. <code>init i</code> takes the child rank <code>i</code> as parameter (first forked child has rank 0, next 1, etc.).</p></aside><section><header><h4 id="parallel-mapfold"><a href="#parallel-mapfold" class="anchor"></a>Parallel mapfold</h4></header><dl><dt class="spec value" id="val-parmapfold"><a href="#val-parmapfold" class="anchor"></a><code><span class="keyword">val</span> parmapfold : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p><code>parmapfold ~ncores:n f (L l) op b concat </code> computes <code>List.fold_right op (List.map f l) b</code> by forking <code>n</code> processes on a multicore machine. You need to provide the extra <code>concat</code> operator to combine the partial results of the fold computed on each core. If 'b = 'c, then <code>concat</code> may be simply <code>op</code>. The order of computation in parallel changes w.r.t. sequential execution, so this function is only correct if <code>op</code> and <code>concat</code> are associative and commutative. If the optional <code>chunksize</code> parameter is specified, the processes compute the result in an on-demand fashion on blocks of size <code>chunksize</code>. <code>parmapfold ~ncores:n f (A a) op b concat </code> computes <code>Array.fold_right op (Array.map f a) b</code></p></dd></dl></section><section><header><h4 id="parallel-fold"><a href="#parallel-fold" class="anchor"></a>Parallel fold</h4></header><dl><dt class="spec value" id="val-parfold"><a href="#val-parfold" class="anchor"></a><code><span class="keyword">val</span> parfold : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'b</span></code></dt><dd><p><code>parfold ~ncores:n op (L l) b concat</code> computes <code>List.fold_right op l b</code> by forking <code>n</code> processes on a multicore machine. You need to provide the extra <code>concat</code> operator to combine the partial results of the fold computed on each core. If 'b = 'c, then <code>concat</code> may be simply <code>op</code>. The order of computation in parallel changes w.r.t. sequential execution, so this function is only correct if <code>op</code> and <code>concat</code> are associative and commutative. If the optional <code>chunksize</code> parameter is specified, the processes compute the result in an on-demand fashion on blocks of size <code>chunksize</code>. <code>parfold ~ncores:n op (A a) b concat</code> similarly computes <code>Array.fold_right op a b</code>.</p></dd></dl></section><section><header><h4 id="parallel-map"><a href="#parallel-map" class="anchor"></a>Parallel map</h4></header><dl><dt class="spec value" id="val-parmap"><a href="#val-parmap" class="anchor"></a><code><span class="keyword">val</span> parmap : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p><code>parmap  ~ncores:n f (L l) </code> computes <code>List.map f l</code> by forking <code>n</code> processes on a multicore machine. <code>parmap  ~ncores:n f (A a) </code> computes <code>Array.map f a</code> by forking <code>n</code> processes on a multicore machine. If the optional <code>chunksize</code> parameter is specified, the processes compute the result in an on-demand fashion on blocks of size <code>chunksize</code>; this provides automatic load balancing for unbalanced computations, but the order of the result is no longer guaranteed to be preserved.</p></dd></dl></section><section><header><h4 id="parallel-iteration"><a href="#parallel-iteration" class="anchor"></a>Parallel iteration</h4></header><dl><dt class="spec value" id="val-pariter"><a href="#val-pariter" class="anchor"></a><code><span class="keyword">val</span> pariter : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pariter  ~ncores:n f (L l) </code> computes <code>List.iter f l</code> by forking <code>n</code> processes on a multicore machine. <code>parmap  ~ncores:n f (A a) </code> computes <code>Array.iter f a</code> by forking <code>n</code> processes on a multicore machine. If the optional <code>chunksize</code> parameter is specified, the processes perform the computation in an on-demand fashion on blocks of size <code>chunksize</code>; this provides automatic load balancing for unbalanced computations.</p></dd></dl></section><section><header><h4 id="parallel-mapfold,-indexed"><a href="#parallel-mapfold,-indexed" class="anchor"></a>Parallel mapfold, indexed</h4></header><dl><dt class="spec value" id="val-parmapifold"><a href="#val-parmapifold" class="anchor"></a><code><span class="keyword">val</span> parmapifold : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>Like parmapfold, but the map function gets as an extra argument the index of the mapped element</p></dd></dl></section><section><header><h4 id="parallel-map,-indexed"><a href="#parallel-map,-indexed" class="anchor"></a>Parallel map, indexed</h4></header><dl><dt class="spec value" id="val-parmapi"><a href="#val-parmapi" class="anchor"></a><code><span class="keyword">val</span> parmapi : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> list</span></code></dt><dd><p>Like parmap, but the map function gets as an extra argument the index of the mapped element</p></dd></dl></section><section><header><h4 id="parallel-iteration,-indexed"><a href="#parallel-iteration,-indexed" class="anchor"></a>Parallel iteration, indexed</h4></header><dl><dt class="spec value" id="val-pariteri"><a href="#val-pariteri" class="anchor"></a><code><span class="keyword">val</span> pariteri : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Like pariter, but the iterated function gets as an extra argument the index of the sequence element</p></dd></dl></section><section><header><h4 id="parallel-map-on-arrays"><a href="#parallel-map-on-arrays" class="anchor"></a>Parallel map on arrays</h4></header><dl><dt class="spec value" id="val-array_parmap"><a href="#val-array_parmap" class="anchor"></a><code><span class="keyword">val</span> array_parmap : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> array</span></code></dt><dd><p><code>array_parmap  ~ncores:n f a </code> computes <code>Array.map f a</code> by forking <code>n</code> processes on a multicore machine. If the optional <code>chunksize</code> parameter is specified, the processes compute the result in an on-demand fashion on blochs of size <code>chunksize</code>; this provides automatic load balancing for unbalanced computations, but the order of the result is no longer guaranteed to be preserved.</p></dd></dl></section><section><header><h4 id="parallel-map-on-arrays,-indexed"><a href="#parallel-map-on-arrays,-indexed" class="anchor"></a>Parallel map on arrays, indexed</h4></header><dl><dt class="spec value" id="val-array_parmapi"><a href="#val-array_parmapi" class="anchor"></a><code><span class="keyword">val</span> array_parmapi : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> array</span></code></dt><dd><p>Like array_parmap, but the map function gets as an extra argument the index of the mapped element</p></dd></dl></section></section><section><header><h3 id="float-array-operations"><a href="#float-array-operations" class="anchor"></a>Float array operations</h3></header><dl><dt class="spec exception" id="exception-WrongArraySize"><a href="#exception-WrongArraySize" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">WrongArraySize</span></code></dt></dl><dl><dt class="spec type" id="type-buf"><a href="#type-buf" class="anchor"></a><code><span class="keyword">type</span> buf</code></dt></dl><dl><dt class="spec value" id="val-init_shared_buffer"><a href="#val-init_shared_buffer" class="anchor"></a><code><span class="keyword">val</span> init_shared_buffer : <span>float array</span> <span>&#45;&gt;</span> <a href="index.html#type-buf">buf</a></code></dt><dd><p><code>init_shared_buffer a</code> creates a new memory mapped shared buffer big enough to hold a float array of the size of <code>a</code>. This buffer can be reused in a series of calls to <code>array_float_parmap</code>, avoiding the cost of reallocating it each time.</p></dd></dl><section><header><h4 id="parallel-map-on-float-arrays"><a href="#parallel-map-on-float-arrays" class="anchor"></a>Parallel map on float arrays</h4></header><dl><dt class="spec value" id="val-array_float_parmap"><a href="#val-array_float_parmap" class="anchor"></a><code><span class="keyword">val</span> array_float_parmap : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;result:<span>float array</span></span> <span>&#45;&gt;</span> <span>?&#8288;sharedbuffer:<a href="index.html#type-buf">buf</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span>float array</span></code></dt><dd><p><code>array_float_parmap  ~ncores:n f a </code> computes <code>Array.map f a</code> by forking <code>n</code> processes on a multicore machine, and preallocating the resulting array as shared memory, which allows significantly more efficient computation than calling the generic array_parmap function. If the optional <code>chunksize</code> parameter is specified, the processes compute the result in an on-demand fashion on blochs of size <code>chunksize</code>; this provides automatic load balancing for unbalanced computations, *and* the order of the result is still guaranteed to be preserved.</p><p>In case you already have at hand an array where to store the result, you can squeeze out some more cpu cycles by passing it as optional parameter <code>result</code>: this will avoid the creation of a result array, which can be costly for very large data sets. Raises <code>WrongArraySize</code> if <code>result</code> is too small to hold the data.</p><p>It is possible to share the same preallocated shared memory space across calls, by initialising the space calling <code>init_shared_buffer a</code> and passing the result as the optional <code>sharedbuffer</code> parameter to each subsequent call to <code>array_float_parmap</code>. Raises WrongArraySize if <code>sharedbuffer</code> is too small to hold the input data.</p></dd></dl></section><section><header><h4 id="parallel-map-on-float-arrays,-indexed"><a href="#parallel-map-on-float-arrays,-indexed" class="anchor"></a>Parallel map on float arrays, indexed</h4></header><dl><dt class="spec value" id="val-array_float_parmapi"><a href="#val-array_float_parmapi" class="anchor"></a><code><span class="keyword">val</span> array_float_parmapi : <span>?&#8288;init:<span>(int <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;finalize:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>?&#8288;ncores:int</span> <span>&#45;&gt;</span> <span>?&#8288;chunksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;result:<span>float array</span></span> <span>&#45;&gt;</span> <span>?&#8288;sharedbuffer:<a href="index.html#type-buf">buf</a></span> <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> float)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> array</span> <span>&#45;&gt;</span> <span>float array</span></code></dt><dd><p>Like array_float_parmap, but the map function gets as an extra argument the index of the mapped element</p></dd></dl></section></section></section><section><header><h2 id="debugging-and-helpers"><a href="#debugging-and-helpers" class="anchor"></a>Debugging and Helpers</h2></header><dl><dt class="spec value" id="val-debugging"><a href="#val-debugging" class="anchor"></a><code><span class="keyword">val</span> debugging : bool <span>&#45;&gt;</span> unit</code></dt><dd><p>Enable or disable debugging code in the library; default: false</p></dd></dl><dl><dt class="spec value" id="val-redirect"><a href="#val-redirect" class="anchor"></a><code><span class="keyword">val</span> redirect : <span>?&#8288;path:string</span> <span>&#45;&gt;</span> <span>id:int</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Helper function that redirects stdout and stderr to files located in the directory <code>path</code>, carrying names of the shape stdout.NNN and stderr.NNN where NNN is the <code>id</code> of the used core. Useful when writing initialisation functions to be passed as <code>init</code> argument to the parallel combinators. The default value for <code>path</code> is /tmp/.parmap.PPPP with PPPP the process id of the main program.</p></dd></dl></section></div></body></html>